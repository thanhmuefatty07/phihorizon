"""
Base Strategy - Abstract base class for trading strategies.

This is a minimal implementation for the walk-forward optimizer.
Buyers can extend this class to create their own strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

import pandas as pd


@dataclass
class TradeSignal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    symbol: str
    direction: str  # 'long', 'short', or 'flat'
    strength: float  # 0.0 to 1.0
    params: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.params is None:
            self.params = {}


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Subclass this to create custom strategies for walk-forward optimization.
    """
    
    def __init__(self, params: Dict[str, Any] = None):
        """Initialize strategy with parameters."""
        self.params = params or {}
        self.name = self.__class__.__name__
        
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[TradeSignal]:
        """
        Generate trading signals from market data.
        
        Args:
            data: OHLCV DataFrame with columns: open, high, low, close, volume
            
        Returns:
            List of TradeSignal objects
        """
        pass
    
    def backtest(self, data: pd.DataFrame) -> Dict[str, float]:
        """
        Run backtest and return performance metrics.
        
        Args:
            data: OHLCV DataFrame
            
        Returns:
            Dict with metrics: sharpe, sortino, max_drawdown, total_return, etc.
        """
        signals = self.generate_signals(data)
        
        # Basic backtest logic
        returns = []
        for i, signal in enumerate(signals):
            if signal.direction == 'long':
                returns.append(0.001 * signal.strength)
            elif signal.direction == 'short':
                returns.append(-0.001 * signal.strength)
            else:
                returns.append(0)
        
        if not returns:
            return {
                'sharpe': 0.0,
                'sortino': 0.0,
                'max_drawdown': 0.0,
                'total_return': 0.0,
                'win_rate': 0.0
            }
        
        import numpy as np
        returns = np.array(returns)
        
        sharpe = np.mean(returns) / (np.std(returns) + 1e-8) * np.sqrt(252)
        sortino = np.mean(returns) / (np.std(returns[returns < 0]) + 1e-8) * np.sqrt(252)
        total_return = np.sum(returns)
        
        return {
            'sharpe': float(sharpe),
            'sortino': float(sortino),
            'max_drawdown': float(np.min(np.minimum.accumulate(np.cumsum(returns)) - np.cumsum(returns))),
            'total_return': float(total_return),
            'win_rate': float(np.mean(returns > 0))
        }
    
    def set_params(self, params: Dict[str, Any]) -> None:
        """Update strategy parameters."""
        self.params.update(params)
    
    def get_params(self) -> Dict[str, Any]:
        """Get current strategy parameters."""
        return self.params.copy()


class RSIStrategy(BaseStrategy):
    """Example RSI-based strategy."""
    
    def __init__(self, params: Dict[str, Any] = None):
        super().__init__(params)
        self.period = self.params.get('period', 14)
        self.overbought = self.params.get('overbought', 70)
        self.oversold = self.params.get('oversold', 30)
    
    def generate_signals(self, data: pd.DataFrame) -> List[TradeSignal]:
        """Generate RSI signals."""
        signals = []
        
        if len(data) < self.period + 1:
            return signals
        
        # Calculate RSI
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.period).mean()
        rs = gain / (loss + 1e-8)
        rsi = 100 - (100 / (1 + rs))
        
        for i in range(self.period, len(data)):
            if rsi.iloc[i] < self.oversold:
                signals.append(TradeSignal(
                    timestamp=data.index[i] if hasattr(data.index[i], 'isoformat') else datetime.now(),
                    symbol='BTC-USD',
                    direction='long',
                    strength=(self.oversold - rsi.iloc[i]) / self.oversold
                ))
            elif rsi.iloc[i] > self.overbought:
                signals.append(TradeSignal(
                    timestamp=data.index[i] if hasattr(data.index[i], 'isoformat') else datetime.now(),
                    symbol='BTC-USD',
                    direction='short',
                    strength=(rsi.iloc[i] - self.overbought) / (100 - self.overbought)
                ))
        
        return signals
